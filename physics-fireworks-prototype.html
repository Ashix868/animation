<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics-Enhanced Fireworks System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #physicsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            pointer-events: none;
        }

        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 300px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .value-display {
            font-size: 11px;
            color: #888;
            text-align: right;
        }

        .launch-btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .launch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="physicsCanvas"></canvas>
    <canvas id="renderCanvas"></canvas>
    
    <div class="control-panel">
        <h3 style="margin-bottom: 15px; text-align: center; color: #4ecdc4;">Physics Fireworks</h3>
        
        <div class="control-group">
            <label>Gravity Strength</label>
            <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.8">
            <div class="value-display" id="gravityValue">0.8</div>
        </div>

        <div class="control-group">
            <label>Wind Force</label>
            <input type="range" id="wind" min="-1" max="1" step="0.1" value="0">
            <div class="value-display" id="windValue">0.0</div>
        </div>

        <div class="control-group">
            <label>Air Resistance</label>
            <input type="range" id="airResistance" min="0" max="0.1" step="0.001" value="0.01">
            <div class="value-display" id="airResistanceValue">0.01</div>
        </div>

        <div class="control-group">
            <label>Particle Count</label>
            <input type="range" id="particleCount" min="50" max="500" step="25" value="200">
            <div class="value-display" id="particleCountValue">200</div>
        </div>

        <div class="control-group">
            <label>Collision Detection</label>
            <input type="checkbox" id="collisions" checked>
            <span>Enable</span>
        </div>

        <div class="control-group">
            <label>Fluid Dynamics</label>
            <input type="checkbox" id="fluidDynamics" checked>
            <span>Enable</span>
        </div>

        <div class="control-group">
            <label>Particle Size</label>
            <input type="range" id="particleSize" min="2" max="8" step="0.5" value="4">
            <div class="value-display" id="particleSizeValue">4</div>
        </div>

        <button class="launch-btn" onclick="launchFireworks()">Launch Fireworks</button>
    </div>

    <div class="status" id="status">
        Particles: 0 | FPS: 60
    </div>

    <script>
        // Physics Engine Setup
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Events = Matter.Events;
        const Vector = Matter.Vector;

        // Create engine and world
        const engine = Engine.create();
        const world = engine.world;
        world.gravity.y = 0.8;

        // Get canvas elements
        const physicsCanvas = document.getElementById('physicsCanvas');
        const renderCanvas = document.getElementById('renderCanvas');
        const physicsCtx = physicsCanvas.getContext('2d');
        const renderCtx = renderCanvas.getContext('2d');

        // Resize canvases
        function resizeCanvases() {
            physicsCanvas.width = window.innerWidth;
            physicsCanvas.height = window.innerHeight;
            renderCanvas.width = window.innerWidth;
            renderCanvas.height = window.innerHeight;
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Physics renderer (hidden, only for physics calculations)
        const render = Render.create({
            canvas: physicsCanvas,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent',
                showVelocity: false,
                showAngleIndicator: false,
                showCollisions: false
            }
        });

        // Particle system
        class PhysicsParticle {
            constructor(x, y, vx, vy, color, size, life) {
                this.body = Bodies.circle(x, y, size, {
                    restitution: 0.3,
                    friction: 0.1,
                    frictionAir: 0.01,
                    density: 0.001
                });
                
                this.color = color;
                this.originalSize = size;
                this.life = life;
                this.maxLife = life;
                this.trail = [];
                this.maxTrailLength = 20;
                this.fluidVelocity = { x: 0, y: 0 };
                this.fluidAcceleration = { x: 0, y: 0 };
                
                World.add(world, this.body);
            }

            update(deltaTime, fluidDynamicsEnabled) {
                this.life -= deltaTime;
                
                // Update trail
                const pos = this.body.position;
                this.trail.push({ x: pos.x, y: pos.y, life: 1.0 });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Update trail life
                this.trail.forEach(point => {
                    point.life -= deltaTime * 0.5;
                });
                this.trail = this.trail.filter(point => point.life > 0);

                // Fluid dynamics simulation
                if (fluidDynamicsEnabled) {
                    this.updateFluidDynamics();
                }

                // Apply fluid forces
                if (fluidDynamicsEnabled) {
                    Body.applyForce(this.body, this.body.position, {
                        x: this.fluidAcceleration.x * 0.001,
                        y: this.fluidAcceleration.y * 0.001
                    });
                }

                // Size based on life
                const lifeRatio = this.life / this.maxLife;
                const currentSize = this.originalSize * lifeRatio;
                Body.scale(this.body, currentSize / this.originalSize);
                this.originalSize = currentSize;

                return this.life > 0;
            }

            updateFluidDynamics() {
                // Simple fluid dynamics simulation
                const neighbors = this.getNearbyParticles(50);
                let fluidForce = { x: 0, y: 0 };
                
                neighbors.forEach(neighbor => {
                    const dx = neighbor.body.position.x - this.body.position.x;
                    const dy = neighbor.body.position.y - this.body.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0 && distance < 50) {
                        const force = (50 - distance) / 50;
                        fluidForce.x += (dx / distance) * force * 0.1;
                        fluidForce.y += (dy / distance) * force * 0.1;
                    }
                });

                // Apply damping
                this.fluidVelocity.x += fluidForce.x;
                this.fluidVelocity.y += fluidForce.y;
                this.fluidVelocity.x *= 0.95;
                this.fluidVelocity.y *= 0.95;

                this.fluidAcceleration = fluidForce;
            }

            getNearbyParticles(radius) {
                return particles.filter(particle => {
                    if (particle === this) return false;
                    const dx = particle.body.position.x - this.body.position.x;
                    const dy = particle.body.position.y - this.body.position.y;
                    return Math.sqrt(dx * dx + dy * dy) < radius;
                });
            }

            render(ctx) {
                const pos = this.body.position;
                const lifeRatio = this.life / this.maxLife;
                
                // Render trail
                if (this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = this.trail[i].life;
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                // Render particle
                ctx.globalAlpha = lifeRatio;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.originalSize, 0, Math.PI * 2);
                ctx.fill();

                // Add glow effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.originalSize * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            destroy() {
                World.remove(world, this.body);
            }
        }

        // Particle management
        let particles = [];
        let lastTime = 0;

        // Color schemes
        const colorSchemes = {
            rainbow: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b'],
            sunset: ['#ff6b6b', '#ffa726', '#ffcc02'],
            ocean: ['#4ecdc4', '#45b7d1', '#96ceb4'],
            fire: ['#ff6b6b', '#ff4757', '#ff6348'],
            cosmic: ['#a55eea', '#26de81', '#fd79a8']
        };

        // Launch fireworks
        function launchFireworks() {
            // Clear existing particles
            particles.forEach(particle => particle.destroy());
            particles = [];

            const count = parseInt(document.getElementById('particleCount').value);
            const size = parseFloat(document.getElementById('particleSize').value);
            const colors = colorSchemes.rainbow;

            // Create explosion at center
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 3;

            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 5 + Math.random() * 10;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed - Math.random() * 5;
                
                const color = colors[Math.floor(Math.random() * colors.length)];
                const life = 3 + Math.random() * 4;
                
                const particle = new PhysicsParticle(
                    centerX + (Math.random() - 0.5) * 20,
                    centerY + (Math.random() - 0.5) * 20,
                    vx, vy, color, size, life
                );
                
                particles.push(particle);
            }
        }

        // Update controls
        function updateControls() {
            // Gravity
            const gravity = parseFloat(document.getElementById('gravity').value);
            world.gravity.y = gravity;
            document.getElementById('gravityValue').textContent = gravity.toFixed(1);

            // Wind
            const wind = parseFloat(document.getElementById('wind').value);
            world.gravity.x = wind;
            document.getElementById('windValue').textContent = wind.toFixed(1);

            // Air resistance
            const airResistance = parseFloat(document.getElementById('airResistance').value);
            particles.forEach(particle => {
                particle.body.frictionAir = airResistance;
            });
            document.getElementById('airResistanceValue').textContent = airResistance.toFixed(3);

            // Particle count
            document.getElementById('particleCountValue').textContent = document.getElementById('particleCount').value;

            // Particle size
            document.getElementById('particleSizeValue').textContent = document.getElementById('particleSize').value;
        }

        // Collision detection
        Events.on(engine, 'collisionStart', function(event) {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                // Find particles involved in collision
                const particleA = particles.find(p => p.body === bodyA);
                const particleB = particles.find(p => p.body === bodyB);
                
                if (particleA && particleB) {
                    // Create collision effect
                    createCollisionEffect(particleA, particleB);
                }
            });
        });

        function createCollisionEffect(particleA, particleB) {
            // Create small explosion at collision point
            const posA = particleA.body.position;
            const posB = particleB.body.position;
            const collisionX = (posA.x + posB.x) / 2;
            const collisionY = (posA.y + posB.y) / 2;

            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                const spark = new PhysicsParticle(
                    collisionX, collisionY, vx, vy,
                    '#ffffff', 2, 1
                );
                particles.push(spark);
            }
        }

        // Animation loop
        function animate(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update physics
            Engine.update(engine, deltaTime * 1000);

            // Update controls
            updateControls();

            // Clear render canvas
            renderCtx.clearRect(0, 0, renderCanvas.width, renderCanvas.height);

            // Update and render particles
            const fluidDynamicsEnabled = document.getElementById('fluidDynamics').checked;
            particles = particles.filter(particle => {
                const alive = particle.update(deltaTime, fluidDynamicsEnabled);
                if (alive) {
                    particle.render(renderCtx);
                } else {
                    particle.destroy();
                }
                return alive;
            });

            // Update status
            const fps = Math.round(1000 / deltaTime);
            document.getElementById('status').textContent = 
                `Particles: ${particles.length} | FPS: ${fps}`;

            requestAnimationFrame(animate);
        }

        // Start animation
        requestAnimationFrame(animate);

        // Add event listeners
        document.getElementById('gravity').addEventListener('input', updateControls);
        document.getElementById('wind').addEventListener('input', updateControls);
        document.getElementById('airResistance').addEventListener('input', updateControls);
        document.getElementById('particleCount').addEventListener('input', updateControls);
        document.getElementById('particleSize').addEventListener('input', updateControls);

        // Auto-launch on load
        setTimeout(launchFireworks, 1000);
    </script>
</body>
</html>